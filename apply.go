package structdiff

import (
	"fmt"
	"reflect"
)

// Apply applies a patch to a target, which can be either a struct or a map.
// For structs: the target must be a pointer to a struct, and the struct is modified in-place.
// For maps: the target must be a pointer to a map[string]any, and the map is replaced with the patched result.
//
// The patch should be generated by Diff, DiffMaps, or follow the same format:
// - Keys with values: set/update the key/field to that value
// - Keys with nil values: delete the key or zero the field if possible
// - Nested maps/structs: recursively apply patches
//
// Returns an error if the patch cannot be applied due to type incompatibilities
// or structural constraints.
func Apply(target any, patch map[string]any) error {
	if patch == nil {
		return nil
	}

	if target == nil {
		return fmt.Errorf("target is nil")
	}

	targetVal := reflect.ValueOf(target)
	if !targetVal.IsValid() {
		return fmt.Errorf("target is nil")
	}

	// Target must be a pointer so we can modify it
	if targetVal.Kind() != reflect.Pointer {
		return fmt.Errorf("target must be a pointer, got %T", target)
	}

	elemVal := targetVal.Elem()
	if !elemVal.IsValid() {
		return fmt.Errorf("target points to nil")
	}

	switch elemVal.Kind() {
	case reflect.Struct:
		// For structs, use ApplyToStruct
		return ApplyToStruct(target, patch)

	case reflect.Map:
		// For maps, check if it's map[string]any
		if elemVal.Type() != reflect.TypeOf(map[string]any{}) {
			return fmt.Errorf("map target must be of type map[string]any, got %s", elemVal.Type())
		}

		// Get the original map
		var originalMap map[string]any
		if !elemVal.IsNil() {
			originalMap = elemVal.Interface().(map[string]any)
		}

		// Apply the patch using ApplyToMap
		resultMap := ApplyToMap(originalMap, patch)

		// Replace the map contents
		elemVal.Set(reflect.ValueOf(resultMap))
		return nil

	default:
		return fmt.Errorf("target must point to a struct or map[string]any, got pointer to %s", elemVal.Kind())
	}
}
