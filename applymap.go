package structdiff

import "reflect"

// ApplyToMap applies a diff/patch to a starting map to produce a new map.
// The patch should be generated by Diff or DiffMaps, or follow the same format:
//
// - Keys with values: set/update the key to that value
// - Keys with nil values: delete the key from the result
// - Nested maps: recursively apply patches to nested maps
// - Struct values: if original value is a struct and patch is a map, apply patch to struct using ApplyToStruct
//
// The original map is not modified; a new map is returned.
func ApplyToMap(original map[string]any, patch map[string]any) map[string]any {
	if original == nil && patch == nil {
		return nil
	}
	if original == nil {
		original = make(map[string]any)
	}
	if patch == nil {
		// No changes to apply, return copy of original
		return copyMap(original)
	}

	// Start with a copy of the original map
	result := copyMap(original)

	// Apply each change in the patch
	for key, patchValue := range patch {
		if patchValue == nil {
			// nil value means delete the key
			delete(result, key)
		} else if isMap(patchValue) {
			// Check if the original also has a map at this key
			if originalValue, exists := result[key]; exists && isMap(originalValue) {
				// Both are maps - recursively apply patch
				originalMap := originalValue.(map[string]any)
				patchMap := patchValue.(map[string]any)
				result[key] = ApplyToMap(originalMap, patchMap)
			} else if originalValue, exists := result[key]; exists && isStruct(originalValue) {
				// Original is a struct, patch is a map - apply patch to struct
				patchMap := patchValue.(map[string]any)

				// Create a copy of the struct and get a pointer to it
				structValue := reflect.ValueOf(originalValue)
				structCopy := reflect.New(structValue.Type()).Elem()
				structCopy.Set(structValue)
				structPtr := structCopy.Addr().Interface()

				// Apply the patch to the struct copy
				if err := ApplyToStruct(structPtr, patchMap); err != nil {
					// If patching fails, replace with the patch map
					result[key] = copyValue(patchValue)
				} else {
					// Use the patched struct
					result[key] = structCopy.Interface()
				}
			} else {
				// Original doesn't have a map or struct here, or has different type
				// Replace with the patch map
				result[key] = copyValue(patchValue)
			}
		} else {
			// Simple value - set/update the key
			result[key] = copyValue(patchValue)
		}
	}

	return result
}

// copyMap creates a shallow copy of a map
func copyMap(m map[string]any) map[string]any {
	if m == nil {
		return nil
	}
	result := make(map[string]any, len(m))
	for k, v := range m {
		result[k] = copyValue(v)
	}
	return result
}

// copyValue creates a copy of a value, handling maps and slices
func copyValue(v any) any {
	if v == nil {
		return nil
	}

	if isMap(v) {
		return copyMap(v.(map[string]any))
	}

	if isSlice(v) {
		slice := v.([]any)
		result := make([]any, len(slice))
		for i, item := range slice {
			result[i] = copyValue(item)
		}
		return result
	}

	if isStruct(v) {
		// For structs, create a copy
		structValue := reflect.ValueOf(v)
		structCopy := reflect.New(structValue.Type()).Elem()
		structCopy.Set(structValue)
		return structCopy.Interface()
	}

	// For basic types, direct assignment is fine (strings, numbers, bools are immutable)
	return v
}
